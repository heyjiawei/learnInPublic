# How is redux toolkit different from redux

## Some problematic areas

- duplication in action and reducer code (action type string)
- switch statements used in reducer

### configureStore

- we need to pass our reducer function as a field named reducer
- the store has been configured to enable using the Redux DevTools Extension to view the history of dispatched actions and how the store state changed
- it has default middlewares. They are:

```
const middleware = [thunk, immutableStateInvariant, serializableStateInvariant]
```

### createAction

- is actually createActionCreator
- the action creator's toString() method has been overridden, and will return the action type string. Second, the type string is also available as a .type field on the function
- By default, the action creators from the RTK createAction function only accept one argument. That argument, whatever it is, is put into the action object as a field called payload.
- RTK allows you to customize how the payload field is created in your action objects. If you are using createAction by itself, you can pass a "prepare callback" as the second argument.
  - Note that the "prepare callback" must return an object with a field called payload inside! Otherwise, the action's payload will be undefined.
  - It may also include a field called meta, which can be used to include extra additional metadata related to the action.

### createReducer

- lets you write reducers using a "lookup table" object, where each key in the object is a Redux action type string, and the values are reducer functions
- the RTK createSlice function allows us to consolidate that logic in one place
- A normal Redux application has a JS object at the top of its state tree, and that object is the result of calling the Redux combineReducers function to join multiple reducer functions into one larger "root reducer"

  - We refer to one key/value section of that object as a "slice", and we use the term "slice reducer" to describe the reducer function responsible for updating that slice of the state.

- **createSlice and createReducer wrap your function with produce from the Immer library. This means you can write code that "mutates" the state inside the reducer, and Immer will safely return a correct immutably updated result.**

### createSlice

- It allows us to provide an object with the reducer functions, and it will automatically generate the action type strings and action creator functions based on the names of the reducers we listed.
- returns a "slice" object that contains the generated reducer function as a field named reducer, and the generated action creators inside an object called actions.
- **createSlice and createReducer wrap your function with produce from the Immer library. This means you can write code that "mutates" the state inside the reducer, and Immer will safely return a correct immutably updated result.**

createSlice takes an options object as its argument, with these options:

- name: a string that is used as the prefix for generated action types
- initialState: the initial state value for the reducer
- reducers: an object, where the keys will become action type strings, and the functions are reducers that will be run when that action type is dispatched

- There's no default handler here. The reducer generated by createSlice will automatically handle all other action types by returning the current state, so we don't have to list that ourselves.

createSlice returns an object that looks like this:

```
{
  name: "todos",
  reducer: (state, action) => newState,
  actions: {
    addTodo: (payload) => ({type: "todos/addTodo", payload}),
    toggleTodo: (payload) => ({type: "todos/toggleTodo", payload})
  },
  caseReducers: {
    addTodo: (state, action) => newState,
    toggleTodo: (state, action) => newState,
  }
}
```

- If you need to customize the payload in createSlice, you can do so by passing an object containing reducer and prepare functions to the reducers object, instead of just the reducer function by itself

```
let nextTodoId = 0

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: {
      reducer(state, action) { // <--
        const { id, text } = action.payload
        state.push({ id, text, completed: false })
      },
      prepare(text) { // <--
        return { payload: { text, id: nextTodoId++ } }
      }
    }
  }
}
```

### createSelector

- re-exported from Reselect
- lets you define "memoized" selector functions. These memoized selectors only recalculate values if the inputs have actually changed.

### createAsyncThunk

- accepts a Redux action type string and a callback function that should return a promise
- returns a thunk action creator that will run the promise callback and dispatch the lifecycle actions based on the returned promise.

- createAsyncThunk accepts three parameters: a string action type value, a payloadCreator callback, and an options object

  - the type is a string that will be used to generate additional Redux action type constants, representing the lifecycle of an async request

- createAsyncThunk will always return a resolved promise with either the fulfilled action object or rejected action object inside, as appropriate.
  - Note that this means a failed request or error in a thunk will never return a rejected promise.
  - If your component needs to know if the request failed, use unwrapResult and handle the re-thrown error accordingly.

# React redux hooks API

## useSelector

`const result: any = useSelector(selector: Function, equalityFn?: Function)`

- selector function should be pure since it is potentially executed multiple times and at arbitrary points in time.
- The selector will be called with the entire Redux store state as its only argument.
  - The selector function does not receive an ownProps argument. However, props can be used through closure or by using a curried selector.
- If the selector function reference hasn't changed since a previous render of the component (so that a cached result can be returned by the hook without re-running the selector), the selector will not run
- also subscribe to the Redux store, and runs your selector whenever an action is dispatched.

- The selector may return any value as a result, not just an object. The return value of the selector will be used as the return value of the useSelector() hook.
- When an action is dispatched, useSelector() will do a reference comparison of the previous selector result value and the current result value. If they are different, the component will be forced to re-render. If they are the same, the component will not re-render.
- useSelector() uses strict === reference equality checks by default, not shallow equality

- Each call to useSelector() creates an individual subscription to the Redux store.

  - but You may call useSelector() multiple times within a single function component
  - Because of the React update batching behavior, a dispatched action that causes multiple useSelector()s in the same component to return new values should only result in a single re-render.

## Differences with rerender and redux dispatch, useSelector and connect()

- When the function component renders, the provided selector function will be called and its result will be returned from the useSelector() hook.

  - A cached result may be returned by the hook without re-running the selector if it's the same function reference as on a previous render of the component.

- when an action is dispatched to the Redux store, useSelector() only forces a re-render if the selector result appears to be different than the last result
  - the default comparison is a strict === reference comparison
  - This is **different than connect()**, which uses **shallow equality checks** on the results of mapState calls to determine if re-rendering is needed.

Between connect() and useSelector():

- With mapState, all individual fields were returned in a combined object. It didn't matter if the return object was a new reference or not - connect() just compared the individual fields.
- With useSelector(), returning a new object every time will always force a re-render by default.

If you want to retrieve multiple values from the store with useSelector(),

1. Call useSelector() multiple times, with each call returning a single field value
2. Use Reselect or a similar library to create a memoized selector that returns multiple values in one object, but only returns a new object when one of the values has changed.
3. Use the shallowEqual function from React-Redux as the equalityFn argument to useSelector()

## useDispatch

`const dispatch = useDispatch()`

- returns a reference to the dispatch function from the Redux store.
- similar to React, the returned dispatch function identity is stable and won't change on re-renders

- when passing a callback using dispatch to a child component, you should memoize it with useCallback, just like you should memoize any passed callback
  - This avoids unnecessary rendering of child components due to the changed callback reference
  - You can safely pass `[dispatch]` in the dependency array for the useCallback call - since dispatch won't change, the callback will be reused properly (as it should)
